export = RelayServer;
declare class RelayServer {
    constructor({ txStoreManager, keyManager, owner, hubAddress, url, baseRelayFee, pctRelayFee, gasPriceFactor, web3provider, workerMinBalance, workerTargetBalance, devMode, Debug }: {
        txStoreManager: any;
        keyManager: any;
        owner: any;
        hubAddress: any;
        url: any;
        baseRelayFee: any;
        pctRelayFee: any;
        gasPriceFactor: any;
        web3provider: any;
        workerMinBalance?: number | undefined;
        workerTargetBalance?: number | undefined;
        devMode: any;
        Debug: any;
    });
    web3: any;
    relayHubContract: any;
    paymasterContract: any;
    lastScannedBlock: number;
    ready: boolean;
    removed: boolean;
    nonceMutex: import("async-mutex/lib/Mutex").default;
    nonces: {
        0: number;
        1: number;
    };
    managerAddress: any;
    getManagerAddress(): any;
    getAddress(index: any): any;
    getMinGasPrice(): number | undefined;
    isReady(): boolean;
    pingHandler(): {
        RelayServerAddress: any;
        RelayManagerAddress: any;
        RelayHubAddress: any;
        MinGasPrice: number | undefined;
        Ready: boolean;
        Version: any;
    };
    createRelayTransaction({ encodedFunction, approvalData, signature, from, to, paymaster, gasPrice, gasLimit, senderNonce, relayMaxNonce, baseRelayFee, pctRelayFee, relayHubAddress }: {
        encodedFunction: any;
        approvalData: any;
        signature: any;
        from: any;
        to: any;
        paymaster: any;
        gasPrice: any;
        gasLimit: any;
        senderNonce: any;
        relayMaxNonce: any;
        baseRelayFee: any;
        pctRelayFee: any;
        relayHubAddress: any;
    }, ...args: any[]): Promise<any>;
    start(): void;
    subscription: any;
    stop(): void;
    _workerSemaphore(blockHeader: any): void;
    _workerSemaphoreOn: boolean | undefined;
    fatal(message: any): void;
    _init(): Promise<void>;
    stakeManagerContract: any;
    topics: string[][] | undefined;
    chainId: any;
    networkId: any;
    rawTxOptions: {
        chain: any;
        hardfork: string;
    } | undefined;
    initialized: boolean | undefined;
    replenishWorker(workerIndex: any): Promise<void>;
    _worker(blockHeader: any): Promise<any>;
    gasPrice: number | undefined;
    lastError: any;
    refreshBalance(): Promise<any>;
    balance: any;
    refreshStake(): Promise<number>;
    stake: number | undefined;
    owner: any;
    unstakeDelay: any;
    withdrawBlock: any;
    _handleRelayRemovedEvent(dlog: any): Promise<void>;
    _handleHubAuthorizedEvent(dlog: any): Promise<any>;
    authorizedHub: boolean | undefined;
    _handleStakedEvent(dlog: any): Promise<any>;
    _registerIfNeeded(): Promise<any>;
    isAddressAdded: boolean | undefined;
    _handleUnstakedEvent(dlog: any): Promise<any>;
    /**
     * resend Txs of all signers (manager, workers)
     * @return the receipt from the first request
     */
    _resendUnconfirmedTransactions(blockHeader: any): Promise<undefined>;
    _resendUnconfirmedTransactionsForSigner(blockHeader: any, signerIndex: any): Promise<any>;
    _sendTransaction({ signerIndex, method, destination, value, gasLimit, gasPrice }: {
        signerIndex: any;
        method: any;
        destination: any;
        value: any;
        gasLimit: any;
        gasPrice: any;
    }): Promise<{
        receipt: any;
        signedTx: any;
    }>;
    _resendTransaction({ tx }: {
        tx: any;
    }): Promise<{
        receipt: any;
        signedTx: any;
    }>;
    _pollNonce(signerIndex: any): Promise<any>;
    _parseEvent(event: any): string | {
        name: any;
        address: any;
        args: {};
    };
}
